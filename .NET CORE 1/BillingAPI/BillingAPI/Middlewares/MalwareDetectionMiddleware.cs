using System.Text.RegularExpressions;

namespace BillingAPI.Middlewares
{
    /// <summary>
    /// Custom middleware class
    /// </summary>
    public class MalwareDetectionMiddleware
    {
        /// <summary>
        /// Declares next delegate
        /// </summary>
        private readonly RequestDelegate _next;

        /// <summary>
        /// Assigns next delegate to next middleware in HTTP request pipeline
        /// </summary>
        /// <param name="next">Next middleware in HTTP request pipeline</param>
        public MalwareDetectionMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        /// <summary>
        /// Checks presence of malware 
        /// </summary>
        /// <param name="httpContext">HTTP request context</param>
        /// <returns>Appropriate message</returns>
        public async Task Invoke(HttpContext httpContext)
        {
            httpContext.Request.EnableBuffering(); // Enable request body buffering

            // Check if the request contains query parameters
            if (httpContext.Request.QueryString.HasValue)
            {
                // Get the query parameters
                var queryParams = httpContext.Request.Query;

                // Iterate through each query parameter
                foreach (var param in queryParams)
                {
                    // Check if the parameter value contains potential malware
                    if (ContainsMalware(param.Value))
                    {
                        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
                        await httpContext.Response.WriteAsync($"Malware detected in query parameter '{param.Key}' value: '{param.Value}'.");
                        return;
                    }
                }
            }

            var requestBodyStream = new MemoryStream();
            await httpContext.Request.Body.CopyToAsync(requestBodyStream);
            requestBodyStream.Seek(0, SeekOrigin.Begin);
            var requestBody = new StreamReader(requestBodyStream).ReadToEnd();

            // Reset stream position before leaving the middleware
            httpContext.Request.Body.Position = 0;

            // Performs malware detection
            if (ContainsMalware(requestBody))
            {
                httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;

                await httpContext.Response.WriteAsJsonAsync(new
                {
                    Message = "Malware detected in the request body!"
                });

                return;
            }

            await _next(httpContext);
        }

        /// <summary>
        /// Try to check weather malware are present or not
        /// </summary>
        /// <param name="content">Suspicious content</param>
        /// <returns>True if malware found, false otherwise</returns>
        private bool ContainsMalware(string content)
        {
            // Regular expressions for common malware patterns
            string[] malwarePatterns = {
                @"(\bexec\s*\(|system\s*\(|shell\s*\(|powershell\s*\(|bash\s+\-c\s+)",
                @"(<script[\s\S]+?>|javascript\s*:[\s\S]+?;|document\.write\s*\(|eval\s*\()",
                @"(\b(select|insert|update|delete|drop|alter)\s+[^\s]+\s+from\s+)"
            };

            foreach (var pattern in malwarePatterns)
            {
                // Regex to search for potential malware patterns
                var regex = new Regex(pattern, RegexOptions.IgnoreCase);

                if (regex.IsMatch(content))
                {
                    return true;
                }
            }

            return false;
        }
    }

    /// <summary>
    /// Adds the middleware to the HTTP request pipeline.
    /// </summary>
    public static class MalwareDetectionMiddlewareExtensions
    {
        public static IApplicationBuilder UseMalwareDetectionMiddleware(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<MalwareDetectionMiddleware>();
        }
    }
}
